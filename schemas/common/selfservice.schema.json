{
  "meta:license": [
    "Copyright 2017 Adobe Systems Incorporated. All rights reserved.",
    "This file is licensed to you under the Apache License, Version 2.0 (the 'License');",
    "you may not use this file except in compliance with the License. You may obtain a copy",
    "of the License at http://www.apache.org/licenses/LICENSE-2.0"
  ],


  "meta:notes" : [
    "This schema is work in progress. So far it has created a self service object with definitions which ",
    "are mostly uris, however, it has not defined any structure under those properties many of which would",
    "be a real object structure. There is an open question as to how much of the implementation detail of ",
    "one mechanism of deploying should be expressed in this schema and how much should be left to the implementation",
    "At present, almost everything is left to the implementation with the selfservice object describing the ",
    "concepts and terminology using uris to refernce implementation details where required.  This may not be sufficiently ",
    "concrete for our purposes. "
  ],
  "$schema": "http://json-schema.org/schema#",
  "$id": "https://ns.adobe.com/xdm/selfservice",
  "title": "Self Service Environment",
  "description": "A Self Service Environment is an environment that allows a system integration or deployer to manage applications. In this schema the majority of properties are URIs to allow this to act as a container for a self service environment. Typically each URI would reference some other location where the implementation or definition is held. How some URIs might be used may not be immediately obvious. For instance, the selfServicePortal property might be sent in a event, which would then allow the recipient of a notification generated from that event to access the correct selfServicePortal instance to respond to the event.",
  "definitions": {
    "selservice" : {
      "properties" : {
        "tenant": {
          "name": "Tenant",
          "description": "A description of an Adobe customer having a contract to use a specific set of services. Usually represented by an IMS organization. A tenant will typically have a URI which can be used to reference the tenant.",
          "type": "string",
          "format": "uri"
        },
        "applicationOwner": {
          "name": "Application Owner",
          "description": "An application owner, distinct from a tenant owns an application and manages its state. Usually identified by a IMS role within an IMS organisation, however in the case of partners and system integrations this does not have to the same IMS organisation as the tenant.",
          "type": "string",
          "format": "uri"
        },
        "application": {
          "name": "Application",
          "description": "A set of code, content, and data that together implement an experience. Some applications do not  allow system integrator, partner or customer customisation.  these applications will be owned and managed by Adobe. Other applications may allow customisation on a per instance basis. These may be applications  managed by the system integrator, partner or customer. An application may have a uri referencing  the definition of the application.",
          "type": "string",
          "format": "uri"
        },
        "environment": {
          "name": "Environment",
          "description": "A deployment may have 1..n environments where the application runs. Each environment serves a purpose  in the CI/CD chain providing a structure whereby changes  to the application can be rolled out. Typically the owner of the application manages transitions between environments. A system integratior,  partner or customer may be the owner of the application expecially where the application has  been extended and customised. In other cases where the application is released and managed by Adobe, the Adobe team will be the owner of the application. An environment may have a  uri referencing the definition of the environment. ",
          "enum": [
                "dev",
                "qe",
                "stage",
                "beta",
                "prod"
              ],
              "meta:enum": {
                "dev": "A development environment for engineering teams to develop and test against prior to releasing to the QE teams.",
                "qe": "A deployment provisioned to statisfy the Quality Engineering process",
                "stage": "A final deployment environment before production. Typically used to perform final testing and give a reference  deployment to the last production deployment",
                "beta": "A production deployment environment used to introduce end users of the application to new features.",
                "prod": "The production deployment environment",
                "*": "any other environment"
              },
          "type": "string"
        },
        "cluster": {
          "name": "Cluster",
          "description": "A group of instances deployed within a environment as part of a topology that deliver a service  within an application often using a single source of persistence. A topology may have one or more clusters. A service is typically delivered by a single cluster. Members of the cluster are typically stateless and disposable, meaning they are created and destroyed to maintain a suitable cluster size to deliver the service against the agreed SLA. A cluster will have a uri refencing the definition of the cluster, including parameters defining its scaling behaviour. ",
          "type": "string",
          "format": "uri"
        },
        "ciCdPipeline": {
          "name": "CI/CD Pipeline",
          "description": "A Continuous Deployment Continuous Integration pipeline is used to deploy an application conforming to a defined topology into an environment. The pipleline runs a standard process that understands the definingion of the topology, environment and application. The pipeline is a shared resource used by many applications and tenants, although special tenants may have customised pipelines. A pipleline will have a URI which defines the API.",
          "type": "string",
          "format": "uri"
        },
        "service": {
          "name": "Service",
          "description": "An application consists of one or more services, deployed into a topology and implemented as a cluster. The service will generally expose an API to consumers however that service may be private to the application. The implimentation of a service my be changes without changing the specification of the service. A service will have a URI defining it.",
          "type": "string",
          "format": "uri"
        },
        "topology": {
          "name": "Topology",
          "description": "A topology is a logical group of services and their implementations that togther form an application. The topology may consist of services and service implementations at differnt layers throughout an application Some services within a topology may be satisfied by shared components, for instance many applications may share an edge traffic load balancer. A service will have a URI defining it.",
          "type": "string",
          "format": "uri"
        },
        "codeRepository": {
          "name": "Code Repository",
          "description": "A Code Repostitory stores the application code and any definitions for topologies, services,  clusters and environments. The CI/CD Pipeline will read the Code repository to perform integration and deploy the application.",
          "type": "string",
          "format": "uri"
        },
        "provisioning": {
          "name": "Provisioning",
          "description": "Provisioning is the operation which sets up everything required by Adobe to allow a tenant to deploy an application. This includes setting up the Code Repository, and allocating any resources that the CI/CD pipeline might require to deploy the application. Provisioning will ensure that any costs or charges are appropriately registerd as being related to the tenant so that billing systems can ensure the tenant is billed. Where the infrastrucutre is dedicated to the tenant, provisioning will ensure that sufficient infratructure is available when the first deployment is being performed. If the infratructure is to be provisioned from a pool, provisioning will ensure that the pool is notified of the level of future demand. Provisioning will understand any legal or juristrictional requirements and constraints that the tenant may have expressed in the contract and ensure that those requiremetns and constraints are satisfied.",
          "type": "string",
          "format": "uri"
        },
        "deployment": {
          "name": "Deployment",
          "description": "Deployment is the final act of deploying an application into an environment prior to going live in that enviroment. This should be achieved via an automated process working from specifcation and configuration stored in the codeRepository. Some applications may require the installation of packages directly into a service or API provided by the application. Where this is the case the deployment process must be capable of supporting that style of deployment and must not make the application or any of its parts available to serve requests while the deployment is incomplete. The deployment process should include stepts to validate that the depoloyment was sucessfull. Deployment is not the same as provisioning, which is a pre-requisite for deployment. Typically a deployment will be perfomed every time changes in the code repository needs to be made available in the environment. Typically the deployment process is implemented by the ciCdPipeline",
          "type": "string",
          "format": "uri"
        },
        "artifact": {
          "name": "Artifact",
          "description": "An Artifact use a package forming the implementation of a service. It is is stored in the artifactRepository publised to the artifactRepository by the ciCdPipeline. An artifact has a version number. Once an artifact with a version number is published it becomes immutable, subject to the versioning policy of the artifactRepository.",
          "type": "string",
          "format": "uri"
        },

        "artifactRepository": {
          "name": "Artifact Repository",
          "description": "An Artifact repository stores released binaries either from vendors (including Adobe) or created by teh ciCdPipeline. These artifacts are used by the deployment pipleine to deploy an application into an environment. The artifactRepository will allow many versions of an artifact to exist and will be organised in a way that will allow artifacts specific to a tenant, application, topology and environment to be stored. The artifact repsitory must not be used to store any sensitive data.",
          "type": "string",
          "format": "uri"
        },
        "selfServiceApi": {
          "name": "Self Service API",
          "description": "The Self Serivce API is a well defined API that will, using the model defined in XDM expose to a suitably authorised client a service implemenation that allows that client to one or more applications within a tenant. The API must maintain tenant boundaries, as defined and controlled by IMS. The API will expose functionality based on managing a multi tenant application, and some will have access to less functionality (eg a end Customer of Adobe managing their own single tenant deployment.)",
          "type": "string",
          "format": "uri"
        },
        "selfServicePortal": {
          "name": "Self Service Portal",
          "description": "A User interface or potal containg all the functionality of the selfServiceApi presented for use byt a human in a web browsesr interface.",
          "type": "string",
          "format": "uri"
        },
        "selfServiceBuild": {
          "name": "Build",
          "description": "The process by which the ciCdPipeline creates a artifact. How the build is performed and what the build creates depends on the source code stored in the codeRepository, which will also contain instructions to perform the build. In the case of a java artifact, the build would typically be performed by maven or gradle. In the case of a docker image, the build might be performed by make.",
          "type": "string",
          "format": "uri"
        },
        "runningInstance": {
          "name": "Instance",
          "description": "An instance is 1 copy of a service implementation running within a cluster within a topology deployed to an environment as an application for a tenant.Where the application is a java application, deployed to a provisioned virtual machine, the instance will be the java process, however where the application has been deployed as part of Ethos or some other container based application the instance will be the running Docker container.",
          "type": "string",
          "format": "uri"
        },
        "qualityGateState" : {
          "name": "Quality Gate",
          "description": "The customer ciCdPipeline defines a number of quality gates that will determine the success or fail of the entire process. If any Pass property being false indicates the quality gate has failed.",
          "type" : "object",
          "properties" : {
              "*Pass" : {
                "type" : "boolean",
                "name" : "*Pass",
                "description": "A quality gate test, false means it failed, true means it passed."
              }
          }
        }
      }
    }
  },
  "allOf": [
     {"$ref":"#/definitions/selservice"},
     {
          "required": [
              "id",
              "tenant",
              "application",
              "environment"
          ]
      }
        
  ]
}
